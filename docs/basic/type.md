---
title: 类型
layout: doc
navbar: true
sidebar: true
aside: true
outline: deep
lastUpdated: true
editLink: true
footer: true
---

## 基本内置类型

### 算术类型

算术类型主要分为整型和浮点型. 尺寸在不同的机器上有所差别. 下表列出了C++标准规定的尺寸的最小值, 同时允许编译器赋予这些类型更大的尺寸.

| 类型         | 含义            | 最小尺寸      |
|--------------|-----------------|---------------|
| bool         | 布尔类型        | 未定义        |
| char         | 字符            | 8 位          |
| wchar_t      | 宽字符          | 16 位         |
| char16_t     | Unicode 字符    | 16 位         |
| char32_t     | Unicode 字符    | 32 位         |
| short        | 短整型          | 16 位         |
| int          | 整型            | 16 位         |
| long         | 长整型          | 32 位         |
| long long    | 长整型          | 64 位         |
| float        | 单精度浮点数    | 6 位有效数字  |
| double       | 双精度浮点数    | 10 位有效数字 |
| long double  | 扩展精度浮点数  | 10 位有效数字 |

C++中最基本的字符类型是`char`, 它用于存储基本字符集中的任意字符的对应数值, 也就是字符在机器字符集中的数值, 通常是一个字节的大小. 

::: tip
在C++中, 基本字符集是指一种最低限度的字符集合, 包含编程语言中必需的字符, 这些字符如字母和数字, 空格, 标点符号, 操作符, 换行符, 回车符, 制表符等等.
:::

C++还提供了多种扩展字符类型, 以支持更大范围的字符集(国际化), 这些类型包括`wchar_t`, `char16_t`和`char32_t`. `wchar_t`是C++早期设计的宽字符类型, 不针对Unicode, 用于表示大于一个字节的字符, 它的大小在不同的平台上不一致. `char16_t`和`char32_t`由C++11引入, 是专门为Unicode设计的, 大小固定, 能够确保跨平台统一, 一致.

除了字符类型外, C++中的其他整数类型可能表示不同大小的整数. 标准规定`int`至少和`short`一样大, `long`至少和`int`一样大, `long long`至少和`long`一样大.

浮点型可以表示单精度, 双精度和扩展精度值, C++标准制定了一个浮点数有效位数的最小值, 然而大多数编译器都实现了更高的精度. 通常, `float`以1个字(32bit)来表示, `double`以2个字(64bit)来表示, `long double`以3个或4个字(96或128bit)来表示. 一般来说, 类型`float`和`double`分别有7和16个有效位, 类型`long double`常被用于有特殊浮点需求的硬件, 具体实现不同, 精度也不同.

::: tip
可寻址的最小内存块称为“字节”, 存储的基本单元称为“字”, 它通常是由几个字节组成的. 大多数机器的字节由8bit构成, 字则由32或者64bit构成, 也就是4或者8字节.
:::

#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外, 其他整型可以划分为带符号的(signed)和无符号的(unsigned)两种, 带符号类型可以表示正数, 负数或0, 无符号类型则仅能表示大于等于0的值.

类型`int`, `short`, `long`和`long long`都是带符号的, 通过在这些类型前面添加`unsigned`就可以得到无符号类型, 例如`unsigned long`, 类型`unsigned int`可以缩写为`unsigned`.

与其他整型不同, 字符型被分为了三种: `char`, `signed char`和`unsigned char`. 特别需要注意的是, 类型`char`和类型`signed char`并不一样. 因为`char`在某些编译器上可以视为无符号的, 有些视为有符号的(C++没有规定`char`是否带符号), 对于`unsigned char`, 在8位的情况下, 它可以表示从0到255之间的值; 对于`signed char`, 理论上应该表示-127到127的范围, 但是在大多数计算机上通常是-128到127.

::: warning
如何选择类型?
- 当明确知道数值不可能为负的时候, 应该选用无符号类型
- 使用`int`执行整数运算, 如果数值超过了`int`的范围, 用`long long`
- 不要在算术表达式里面用`char`和`bool`, 只有在存放字符或者布尔值的时候才使用它们. 因为类型`char`在某些机器上是有符号的, 在另一些机器上是无符号的, 如果用`char`进行算术运算很容易出错, 需要制定类型为`signed char`/`unsigned char`
- 执行浮点数运算选用`double`, 这是因为`float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几. 对于某些机器来说, 双精度甚至比单精度快
:::

### 类型转换

对象的类型定义了对象能包含的数据和能参与的运算, 其中一种运算是被大多数类型支持的, 就是将对象从一种给定类型转换到另一种类型. 

当在程序中我们使用了一种类型而其实对象应该采取另一种类型的时候, 程序会进行自动类型转换. 如给某种类型的对象强行赋予了另一种类型的值的时候, 类型所能表示的值的范围决定了转换过程:

- 当我们将一个非布尔类型的算术赋值给布尔类型的时候, 初始值为0的结果为`false`, 否则结果为`true`
- 当我们将一个布尔值复制给非布尔类型的时候, 初始值为`false`, 初始值为`true`则结果为1
- 当我们把一个浮点数赋值给整数类型的时候, 进行了近似处理, 结果值将仅保留浮点数中小数点之前的部分
- 当我们把一个整数值赋值给浮点类型的时候, 小数部分记为0, 如果整数所占的空间超过了浮点类型的容量, 精度可能会有损失
- 当我们赋给一个无符号类型一个超过它表示范围的值时, 结果是初始值对无符号类型表示数值总数取模后的余数. 例如, 8bit大小的`unsigned char`可以表示0到255区间范围内的值, 所以如果赋了一个区间以外的值, 实际结果是该值对256取模后所得的余数, 因此, 把-1复制给8bit大小的`unsigned char`所得的结果是255
- 当我们赋给带符号类型一个超出它表示范围的值时, 结果是未定义. 此时, 程序可能继续工作, 可能奔溃, 也可能生成垃圾数据

::: warning
“无法预知”的行为源于编译器无须(有时候是不能)检测的错误, 即使代码编译通过了, 如果程序执行了一条未定义的表达式, 仍有可能产生错误. 不幸的是, 在某些情况/某些编译器下, 含有无法预知行为的程序也能正常执行, 但是我们无法确保同样一个程序在别的编译器下能够正常工作, 甚至是已经编译通过的代码再次执行也可能会出错. 此外, 也不能认为程序对一组输入有效, 对另一组输入就一定有效. 程序也应该尽量避免依赖于实现环境的行为. 如果我们把`int`的尺寸看成是一个确定不变的值, 那么这样的程序就被称为是“不可移植的”. 当程序移植到别的机器上后, 依赖于当前实现环境的程序就可能发生错误.
:::

当在程序的某处使用了算术类型而需求是另一种类型的时候, 编译器同样会自动执行上述转换. 例如, 如果我们使用了一个非布尔值作为条件, 那么它会被自动转换为布尔值. 这一做法和把非布尔值赋值给布尔变量的操作完全一样.

#### 含有无符号类型的表达式

尽管我们在正常写代码的时候, 不会故意给无符号对象赋一个负值, 但是很容易写出怎么做的代码. 例如, 当一个算术表达式中既有无符号数又有`int`值的时候, 那个`int`值就会转换成无符号数. 

::: details
```c++
unsigned u = 20;
int i = -42;
std::cout << i + i << std::endl;
std::cout << u + i << std::endl;
```
在第一个输出表达式里, 两个负整数相加得到了-84. 在第二个输出表达式里, 相加前首先把整数-42转换为无符号数, 把负数转换为无符号数的过程之前讲过了, 类似于直接给无符号数赋一个负值, 结果等于这个负数加上无符号数的模.
:::

当从无符号数中减去一个值的时候, 不管这个值是不是无符号数, 我们必须确保结果不可能是一个负值.

::: details
```c++
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl;
std::cout << u2 - u1 << std::endl;
```
第一个正确, 输出32; 第二个错误, 输出的是取模后的值.
:::

无符号数不会小于0这个事实会影响到循环的写法.

::: details
```c++
for (unsigned int i = 10; i >= 0; --i)
	std::cout << i << std::endl;
```
这可能会导致`i`永远大于0. 因为等于0的下一次迭代中, 它会减一, 然后会被自动转换成一个合法的无符号数, 假设int类型占32字节, 则会被转换为4294967295.

一种解决的方法是, 用`while`语句代替`for`语句, 因为前者能够先查再减.
```c++
unsigned u = 11;
while (u > 0) {
	--u;
	std::cout << u << std::endl;
}
```
:::

::: warning
切勿混用带符号类型和无符号类型. 这会导致有符号数被自动转换为带符号数, 结果错误.
:::

### 字面量常量

一个形如42的值被称为字面量(literal). 每个字面量都对应一种数据类型, 字面量的形式和值决定了它的数据类型. 

#### 整型和浮点型字面量

我们可以将整型字面量写作十进制数, 八进制数和十六进制数的形式. 以0开头的整数代表八进制数, 以0x或0X开头的代表十六进制数. 例如, 我们可以用任意一种来表示数值20: 20(十进制), 024(八进制), 0x14(十六进制). 

整型字面量的具体数据类型由它的值和符号决定. 默认情况下, 十进制字面量是带符号数, 八进制和十六进制字面量既可以是带符号也可以是不带符号的. 十进制字面量是能够容纳那个值的情况下, `int`, `long`和`long long`中最小的那个. 八进制和十六进制字面量的类型是能够容纳其数值的`int`, `unsigned int`, `long`, `unsigned long`, `long long`和`unsigned long long`中尺寸最小的那个. 如果一个字面量连与之关联的最大的数据类型都放不下, 会产生错误. 类型`short`没有对应的字面量.

尽管整型字面值可以存储在带符号数据类型中, 但是严格来说, 十进制的整型字面量本身不会是负数. 举个例子, 当我们写-42的时候, 42是一个正的十进制整数字面量, 而前面的-是一个操作符, 它的作用是对这个字面量取负值, 所以严格来说, -42不是一个负数字面量, 而是操作符-作用于整数42的结果.

浮点型字面量表现为一个小数或者以科学计数法表示的指数, 其中指数部分用E或者e标识: 3.149, 3.14159E0, 0., 0e0, .001. 默认下, 浮点型字面量是一个`double`. 

#### 字符和字符串字面量

由单个引号括起来的一个字符称为`char`型字面量, 双括号括起来的零个或者多个字符则构成字符串型字面量. 字符串字面量的类型实际上是由常量字符构成的数组. 编译器会在每个字符串的结尾处添加一个空字符('\0'), 因此, 字符串字面量的实际长度要比它的内容多1. 例如, 字面量'A'表示的就是单独的字符A, 而字符串"A"则代表了一个字符的数组, 该数组包含两个字符: 一个是字母A, 另一个是空字符.
 
如果两个字符串字面量位置紧邻且仅由空格, 缩进和换行符分隔, 则它们实际上是一个整体. 当书写的字符串字面量比较长, 写在一行里面不太合适的时候, 就可以采取分开书写的方式.

::: details
```c++
std::cout << "a really, really long string literal "
	"that spans two lines" << std::endl;
```
:::

#### 转义序列

有两类字符程序员不能直接使用: 一类是不可打印的字符, 如退格或者其他控制字符, 因为它们没有可视的图符, 另一类是在C++语言中由特殊含义的字符(单引号, 双引号, 问号, 反斜线). 在这些情况下需要用到转义序列(escape sequence), 转义序列均以反斜线作为开始, C++语言规定的转义序列包括:

- 换行符：`\n`
- 纵向制表符：`\v`
- 反斜线：`\\`
- 回车符：`\r`
- 横向制表符：`\t`
- 退格符：`\b`
- 问号：`\?`
- 进纸符：`\f`
- 报警（响铃）符：`\a`
- 双引号：`\"`
- 单引号：`\'`

在程序中, 上述的转移字符会被当做一个字符使用. 我们也可以使用泛化的转义序列, 其形式是`\x`后面紧跟1个或者多个十六进制数字, 或者`\`后面紧跟1个, 2个或者3个八进制数字, 其中数字部分表示的是字符对应的数值. 假设使用的是Latin-1字符集, 一些示例: `\7`(响铃), `\115`(字符M), `\x4d`(字符M), `\0`空格符. 注意, 如果反斜杠`\`后面跟着的八进制数字超过3个, 只有前三个数字和`\`构成转义序列. 例如, `\1234`表示2个字符, 即八进制数字123对应的字符和字符4. 相反, `\x`要用到后面跟着的所有数字, 例如, `\x1234`表示一个16位的字符, 该字符由这4个十六进制数所对应的比特唯一确定. 因为大多数机器的`char`型数据占8位, 所以上面的这个例子可能会报错.

#### 指定字面量的类型

通过添加下表所列的前缀和后缀, 可以改变整型, 浮点型和字符型字面量的默认类型.

##### 字符和字符串字面量

| 前缀      | 含义                     | 类型         |
|-----------|--------------------------|--------------|
| u         | Unicode 16 字符           | char16_t     |
| U         | Unicode 32 字符           | char32_t     |
| L         | 宽字符                   | wchar_t      |
| u8        | UTF-8 (仅用于字符串字面常量) | char         |

##### 整型字面量

| 后缀      | 最小匹配类型              |
|-----------|---------------------------|
| u or U    | unsigned                  |
| l or L    | long                      |
| ll or LL  | long long                 |

对于一个整型字面量来说, 我们能够分别指定它是否带有符号以及占用多少空间. 如果后缀中有`U`, 则该字面量属于无符号类型, 也就是说, 以`U`为后缀的十进制数, 八进制数或者十六进制数都将从`unsigned int`, `unsigned long`和`unsigned long long`中选择能匹配的空间最小的一个作为其数据类型. 如果后缀中有`L`, 则字面量的类型至少是`long`. 如果后缀中有`ll`, 则字面量的类型将会是`long long`和`unsigned long long`中的一种. 可以将`U`和`L`或者`LL`混在一起使用. 例如, 以`UL`为后缀的字面量的数据类型将根据数值情况或者取`unsigned long`, 或者取`unsigned long long`.

##### 浮点型字面量

| 后缀      | 类型                      |
|-----------|---------------------------|
| f or F    | float                     |
| l or L    | long double               |
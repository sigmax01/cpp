---
title: 类型
layout: doc
navbar: true
sidebar: true
aside: true
outline: deep
lastUpdated: true
editLink: true
footer: true
---

# 类型

## 基本内置类型

C++定义了一套包括算数类型和空类型在内的基本数据类型. 其中算数类型包含了字符, 整型数, 布尔值和浮点数. 空类型不对应具体的值, 仅用于一些特殊的场合, 例如最常见的是, 当函数不返回任何值的时候使用空类型作为返回值.

### 算术类型

算术类型主要分为整型和浮点型. 尺寸在不同的机器上有所差别. 下表列出了C++标准规定的尺寸的最小值, 同时允许编译器赋予这些类型更大的尺寸.

| 类型         | 含义            | 最小尺寸      |
|--------------|-----------------|---------------|
| bool         | 布尔类型        | 未定义        |
| char         | 字符            | 8 位          |
| wchar_t      | 宽字符          | 16 位         |
| char16_t     | Unicode 字符    | 16 位         |
| char32_t     | Unicode 字符    | 32 位         |
| short        | 短整型          | 16 位         |
| int          | 整型            | 16 位         |
| long         | 长整型          | 32 位         |
| long long    | 长整型          | 64 位         |
| float        | 单精度浮点数    | 6 位有效数字  |
| double       | 双精度浮点数    | 10 位有效数字 |
| long double  | 扩展精度浮点数  | 10 位有效数字 |

C++中最基本的字符类型是`char`, 它用于存储基本字符集中的任意字符的对应数值, 也就是字符在机器字符集中的数值, 通常是一个字节的大小. 

::: tip
在C++中, 基本字符集是指一种最低限度的字符集合, 包含编程语言中必需的字符, 这些字符如字母和数字, 空格, 标点符号, 操作符, 换行符, 回车符, 制表符等等.
:::

C++还提供了多种扩展字符类型, 以支持更大范围的字符集(国际化), 这些类型包括`wchar_t`, `char16_t`和`char32_t`. `wchar_t`是C++早期设计的宽字符类型, 不针对Unicode, 用于表示大于一个字节的字符, 它的大小在不同的平台上不一致. `char16_t`和`char32_t`由C++11引入, 是专门为Unicode设计的, 大小固定, 能够确保跨平台统一, 一致.

除了字符类型外, C++中的其他整数类型可能表示不同大小的整数. 标准规定`int`至少和`short`一样大, `long`至少和`int`一样大, `long long`至少和`long`一样大.

浮点型可以表示单精度, 双精度和扩展精度值, C++标准制定了一个浮点数有效位数的最小值, 然而大多数编译器都实现了更高的精度. 通常, `float`以1个字(32bit)来表示, `double`以2个字(64bit)来表示, `long double`以3个或4个字(96或128bit)来表示. 一般来说, 类型`float`和`double`分别有7和16个有效位, 类型`long double`常被用于有特殊浮点需求的硬件, 具体实现不同, 精度也不同.

::: tip
可寻址的最小内存块称为"字节", 存储的基本单元称为"字", 它通常是由几个字节组成的. 大多数机器的字节由8bit构成, 字则由32或者64bit构成, 也就是4或者8字节.
:::

#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外, 其他整型可以划分为带符号的(signed)和无符号的(unsigned)两种, 带符号类型可以表示正数, 负数或0, 无符号类型则仅能表示大于等于0的值.

类型`int`, `short`, `long`和`long long`都是带符号的, 通过在这些类型前面添加`unsigned`就可以得到无符号类型, 例如`unsigned long`, 类型`unsigned int`可以缩写为`unsigned`.

与其他整型不同, 字符型被分为了三种: `char`, `signed char`和`unsigned char`. 特别需要注意的是, 类型`char`和类型`signed char`并不一样. 因为`char`在某些编译器上可以视为无符号的, 有些视为有符号的(C++没有规定`char`是否带符号), 对于`unsigned char`, 在8位的情况下, 它可以表示从0到255之间的值; 对于`signed char`, 理论上应该表示-127到127的范围, 但是在大多数计算机上通常是-128到127.

::: warning
如何选择类型?
- 当明确知道数值不可能为负的时候, 应该选用无符号类型
- 使用`int`执行整数运算, 如果数值超过了`int`的范围, 用`long long`
- 不要在算术表达式里面用`char`和`bool`, 只有在存放字符或者布尔值的时候才使用它们. 因为类型`char`在某些机器上是有符号的, 在另一些机器上是无符号的, 如果用`char`进行算术运算很容易出错, 需要制定类型为`signed char`/`unsigned char`
- 执行浮点数运算选用`double`, 这是因为`float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几. 对于某些机器来说, 双精度甚至比单精度快
:::

### 类型转换

对象的类型定义了对象能包含的数据和能参与的运算, 其中一种运算是被大多数类型支持的, 就是将对象从一种给定类型转换到另一种类型. 

当在程序中我们使用了一种类型而其实对象应该采取另一种类型的时候, 程序会进行自动类型转换. 如给某种类型的对象强行赋予了另一种类型的值的时候, 类型所能表示的值的范围决定了转换过程:

- 当我们将一个非布尔类型的算术赋值给布尔类型的时候, 初始值为0的结果为`false`, 否则结果为`true`
- 当我们将一个布尔值复制给非布尔类型的时候, 初始值为`false`, 初始值为`true`则结果为1
- 当我们把一个浮点数赋值给整数类型的时候, 进行了近似处理, 结果值将仅保留浮点数中小数点之前的部分
- 当我们把一个整数值赋值给浮点类型的时候, 小数部分记为0, 如果整数所占的空间超过了浮点类型的容量, 精度可能会有损失
- 当我们赋给一个无符号类型一个超过它表示范围的值时, 结果是初始值对无符号类型表示数值总数取模后的余数. 例如, 8bit大小的`unsigned char`可以表示0到255区间范围内的值, 所以如果赋了一个区间以外的值, 实际结果是该值对256取模后所得的余数, 因此, 把-1复制给8bit大小的`unsigned char`所得的结果是255
- 当我们赋给带符号类型一个超出它表示范围的值时, 结果是未定义. 此时, 程序可能继续工作, 可能奔溃, 也可能生成垃圾数据

::: warning
"无法预知"的行为源于编译器无须(有时候是不能)检测的错误, 即使代码编译通过了, 如果程序执行了一条未定义的表达式, 仍有可能产生错误. 不幸的是, 在某些情况/某些编译器下, 含有无法预知行为的程序也能正常执行, 但是我们无法确保同样一个程序在别的编译器下能够正常工作, 甚至是已经编译通过的代码再次执行也可能会出错. 此外, 也不能认为程序对一组输入有效, 对另一组输入就一定有效. 程序也应该尽量避免依赖于实现环境的行为. 如果我们把`int`的尺寸看成是一个确定不变的值, 那么这样的程序就被称为是"不可移植的". 当程序移植到别的机器上后, 依赖于当前实现环境的程序就可能发生错误.
:::

当在程序的某处使用了算术类型而需求是另一种类型的时候, 编译器同样会自动执行上述转换. 例如, 如果我们使用了一个非布尔值作为条件, 那么它会被自动转换为布尔值. 这一做法和把非布尔值赋值给布尔变量的操作完全一样.

#### 含有无符号类型的表达式

尽管我们在正常写代码的时候, 不会故意给无符号对象赋一个负值, 但是很容易写出怎么做的代码. 例如, 当一个算术表达式中既有无符号数又有`int`值的时候, 那个`int`值就会转换成无符号数. 

::: details
```c++
unsigned u = 20;
int i = -42;
std::cout << i + i << std::endl;
std::cout << u + i << std::endl;
```
在第一个输出表达式里, 两个负整数相加得到了-84. 在第二个输出表达式里, 相加前首先把整数-42转换为无符号数, 把负数转换为无符号数的过程之前讲过了, 类似于直接给无符号数赋一个负值, 结果等于这个负数加上无符号数的模.
:::

当从无符号数中减去一个值的时候, 不管这个值是不是无符号数, 我们必须确保结果不可能是一个负值.

::: details
```c++
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl;
std::cout << u2 - u1 << std::endl;
```
第一个正确, 输出32; 第二个错误, 输出的是取模后的值.
:::

无符号数不会小于0这个事实会影响到循环的写法.

::: details
```c++
for (unsigned int i = 10; i >= 0; --i)
	std::cout << i << std::endl;
```
这可能会导致`i`永远大于0. 因为等于0的下一次迭代中, 它会减一, 然后会被自动转换成一个合法的无符号数, 假设int类型占32字节, 则会被转换为4294967295.

一种解决的方法是, 用`while`语句代替`for`语句, 因为前者能够先查再减.
```c++
unsigned u = 11;
while (u > 0) {
	--u;
	std::cout << u << std::endl;
}
```
:::

::: warning
切勿混用带符号类型和无符号类型. 这会导致有符号数被自动转换为带符号数, 结果错误.
:::

### 字面量常量

一个形如42的值被称为字面量(literal). 每个字面量都对应一种数据类型, 字面量的形式和值决定了它的数据类型. 

#### 整型和浮点型字面量

我们可以将整型字面量写作十进制数, 八进制数和十六进制数的形式. 以0开头的整数代表八进制数, 以0x或0X开头的代表十六进制数. 例如, 我们可以用任意一种来表示数值20: 20(十进制), 024(八进制), 0x14(十六进制). 

整型字面量的具体数据类型由它的值和符号决定. 默认情况下, 十进制字面量是带符号数, 八进制和十六进制字面量既可以是带符号也可以是不带符号的. 十进制字面量是能够容纳那个值的情况下, `int`, `long`和`long long`中最小的那个. 八进制和十六进制字面量的类型是能够容纳其数值的`int`, `unsigned int`, `long`, `unsigned long`, `long long`和`unsigned long long`中尺寸最小的那个. 如果一个字面量连与之关联的最大的数据类型都放不下, 会产生错误. 类型`short`没有对应的字面量.

尽管整型字面值可以存储在带符号数据类型中, 但是严格来说, 十进制的整型字面量本身不会是负数. 举个例子, 当我们写-42的时候, 42是一个正的十进制整数字面量, 而前面的-是一个操作符, 它的作用是对这个字面量取负值, 所以严格来说, -42不是一个负数字面量, 而是操作符-作用于整数42的结果.

浮点型字面量表现为一个小数或者以科学计数法表示的指数, 其中指数部分用E或者e标识: 3.149, 3.14159E0, 0., 0e0, .001. 默认下, 浮点型字面量是一个`double`. 

#### 字符和字符串字面量

由单个引号括起来的一个字符称为`char`型字面量, 双括号括起来的零个或者多个字符则构成字符串型字面量. 字符串字面量的类型实际上是由常量字符构成的数组. 编译器会在每个字符串的结尾处添加一个空字符('\0'), 因此, 字符串字面量的实际长度要比它的内容多1. 例如, 字面量'A'表示的就是单独的字符A, 而字符串"A"则代表了一个字符的数组, 该数组包含两个字符: 一个是字母A, 另一个是空字符.
 
如果两个字符串字面量位置紧邻且仅由空格, 缩进和换行符分隔, 则它们实际上是一个整体. 当书写的字符串字面量比较长, 写在一行里面不太合适的时候, 就可以采取分开书写的方式.

::: details
```c++
std::cout << "a really, really long string literal "
	"that spans two lines" << std::endl;
```
:::

#### 转义序列

有两类字符程序员不能直接使用: 一类是不可打印的字符, 如退格或者其他控制字符, 因为它们没有可视的图符, 另一类是在C++中由特殊含义的字符(单引号, 双引号, 问号, 反斜线). 在这些情况下需要用到转义序列(escape sequence), 转义序列均以反斜线作为开始, C++规定的转义序列包括:

- 换行符：`\n`
- 纵向制表符：`\v`
- 反斜线：`\\`
- 回车符：`\r`
- 横向制表符：`\t`
- 退格符：`\b`
- 问号：`\?`
- 进纸符：`\f`
- 报警（响铃）符：`\a`
- 双引号：`\"`
- 单引号：`\'`

在程序中, 上述的转移字符会被当做一个字符使用. 我们也可以使用泛化的转义序列, 其形式是`\x`后面紧跟1个或者多个十六进制数字, 或者`\`后面紧跟1个, 2个或者3个八进制数字, 其中数字部分表示的是字符对应的数值. 假设使用的是Latin-1字符集, 一些示例: `\7`(响铃), `\115`(字符M), `\x4d`(字符M), `\0`空格符. 注意, 如果反斜杠`\`后面跟着的八进制数字超过3个, 只有前三个数字和`\`构成转义序列. 例如, `\1234`表示2个字符, 即八进制数字123对应的字符和字符4. 相反, `\x`要用到后面跟着的所有数字, 例如, `\x1234`表示一个16位的字符, 该字符由这4个十六进制数所对应的比特唯一确定. 因为大多数机器的`char`型数据占8位, 所以上面的这个例子可能会报错.

#### 指定字面量的类型

通过添加下表所列的前缀和后缀, 可以改变整型, 浮点型和字符型字面量的默认类型.

##### 字符和字符串字面量

| 前缀      | 含义                     | 类型         |
|-----------|--------------------------|--------------|
| u         | Unicode 16 字符           | char16_t     |
| U         | Unicode 32 字符           | char32_t     |
| L         | 宽字符                   | wchar_t      |
| u8        | UTF-8 (仅用于字符串字面常量) | char         |

##### 整型字面量

| 后缀      | 最小匹配类型              |
|-----------|---------------------------|
| u or U    | unsigned                  |
| l or L    | long                      |
| ll or LL  | long long                 |

对于一个整型字面量来说, 我们能够分别指定它是否带有符号以及占用多少空间. 如果后缀中有`U`, 则该字面量属于无符号类型, 也就是说, 以`U`为后缀的十进制数, 八进制数或者十六进制数都将从`unsigned int`, `unsigned long`和`unsigned long long`中选择能匹配的空间最小的一个作为其数据类型. 如果后缀中有`L`, 则字面量的类型至少是`long`. 如果后缀中有`ll`, 则字面量的类型将会是`long long`和`unsigned long long`中的一种. 可以将`U`和`L`或者`LL`混在一起使用. 例如, 以`UL`为后缀的字面量的数据类型将根据数值情况或者取`unsigned long`, 或者取`unsigned long long`.

##### 浮点型字面量

| 后缀      | 类型                       |
|-----------|--------------------------|
| f or F    | float                    |
| l or L    | long double              |

#### 布尔字面量和指针字面量

`true`和`false`是布尔类型的字面量. `nullptr`是指针字面量. 后面会有更多的详细介绍.

## 变量

变量提供一个具名的, 可供程序操作的存储空间. C++中的每个变量都有其数据类型, 数据类型决定着变量所占内存空间的大小和布局方式, 该空间能存储的值的范围, 以及变量能够参与的运算. 对于C++程序员来说, "变量"和"对象"一般可以互换使用.

### 变量定义

变量定义的基本形式是: 首先是类型说明符, 随后紧跟由一个或者多个变量名组成的列表, 其中变量名以逗号分割, 最后以分号结束. 列表中的每个变量名的类型都由类型说明符指定, 定义的时候还可以为一个或者多个变量赋初始值.

::: details
```c++
int sum = 0, value,
	units_sold = 0;
Sales_item item; // item的类型是Sales_item
std::string book("0-201-x"); // string是一种库类型, 表示一个可变长的字符序列
```
:::

::: tip
何为对象?

C++程序员在很多场合都会使用对象这个词, 通常情况下, 对象是指一块能够存储数据并具有某种类型的内存空间. 一些人仅在与类有关的场景下才使用"对象"这个词, 另一些人则把已命名的对象和未命名的对象区分开来, 它们把已命名的对象叫做变量, 还有一些人把对象和值区分开来, 其中对象指能够被程序修改的数据, 而值指只读的数据. 本项目遵循大多人的习惯用法, 即认为对象是具有某种数据类型的内存空间. 我们在使用对象这个词的时候, 并不严格区分是类还是内置类型, 也不区分是否命名或是否只读.
:::

#### 初始值

当对象在创建的时候获得了一个特定的值, 我们说这个对象被初始化了. 当一次定义两个或者多个变量的时候, 对象的名字会随变量变得立即可用. 因此在同一条定义语句中, 可以用先定义的变量去初始化后定义的其他变量.

::: details
```c++
double price = 109.99, discount = price * 0.16;
double salePrice = applyDiscount(price, discount);
```
:::

#### 列表初始化

在实际的编程中, 对于不同的变量, 初始化的手段多种多样, 这些不同的初始化方法都有各自的适用范围, C++11中为了统一初始化的方式, 引入了列表初始化的概念, 它使用花括号来初始化变量和对象, 可以用在几乎所有的数据类型上, 包括基本数据类型, 类对象, 数组, 结构体等. 

::: details
```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```
其中, 第二种和第三种是列表初始化.
:::

使用列表初始化还能防范数据丢失的风险. 对于内置类型的变量, 如果我们使用列表初始化且初始值存在丢失信息的风险, 则编译器将报错.

::: details
```c++
long double ld = 3.14159;
int a{ld}, b = {ld}; // 错误, 因为存在丢失信息的风险
int c(ld), d = ld; // 正确, 且确实丢失了部分值
```
使用`long double`的值初始化`int`变量的时候可能丢失数据, 所以编译器拒绝了第二行中`a`和`b`的初始化请求. 其中, 至少`ld`的小数部分会丢失掉, 而且`int`可能存不下`ld`的整数部分.	
:::

#### 默认初始化

如果定义变量的时候没有指定初始值, 那么变量会被默认初始化. 默认值由变量类型决定, 同时定义变量的位置也会对此有影响.

全局便来你给或者在函数体之外的变量如果是内置类型且未被初始化, 则会被默认初始化为0. 局部变量如果是内置类型且未被初始化, 则其值是自定义的. 未定义的值意味着使用它们会导致不可预测的行为, 导致错误.

每个类可以自定义其对象的初始化方式. 对于类对象的默认初始化行为, 取决于类的设计. 有些类定义了默认构造函数, 因此可以生成合理的默认值, 例如, `std::string`类型在默认初始化的时候会生成一个空字符串; 也有一些不允许对象没有显式初始化就被定义, 这种情况下, 必须为对象提供初始值, 否则编译器会报错.

::: warning
未初始化的变量含有一个不确定的值, 使用未初始化变量的值是一种错误的编程行为并且很难调试, 尽管大多数编辑器都能对一部分使用未初始化变量的行为提出警告. 但是严格来说, 编译器并未要求检查此类错误.

使用未初始化的变量将带来无法预计的后果. 有时候我们足够幸运, 一访问此类对象就奔溃报错. 此时只需要找到奔溃的位置就很容易发现我们对变量没有初始化的问题. 另外一些时候, 程序会一直执行完并产生错误的结果. 更糟糕的情况是, 程序结果时对时错, 无法把我. 而且, 往无关的位置添加代码还会导致我们误以为程序对了, 其实结果仍旧有错.

所以, 建议初始化每一个内置类型的变量. 虽然并非必须这么做, 但是如果我们不能确保初始化后程序的安全, 那么这么做不失为一种简单可靠的方法.
:::

### 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写, C++支持分离式编译机制, 该机制允许将程序分割成若干个文件, 每个文件都可以独立编译. 

如果将程序分为多个文件, 则需要有在文件之间共享代码的方法. 例如, 一个文件的代码可能需要使用另一个文件中定义的变量. 一个实际的例子是`std::cout`和`std::cin`, 它们用于定义标准库, 却能被我们写的程序使用.

为了支持分离式编译, C++将声明和定义区分开来. 声明使得名字为程序所知, 一个文件如果想使用别处定义的名字则必须包含对那个名字的声明, 而定义负责创建与名字相关联的实体.

变量声明规定了变量的类型和名字, 在这一点上定义与之相同. 但是除此之外, 定义还申请存储空间, 也可能会为变量赋一个初始值.

就例如头文件和库文件的关系. 头文件相当于告诉编译器有哪些章节(声明)和它们的概述(类型, 参数等). 而库文件则提供了每个章节的实际内容(定义和实现), 保证在链接阶段, 符号可以被正确替换为库文件中的实际内容.

如果想声明一个变量而不是定义它, 可以在变量前面加上关键字`extern`, 而且不要显式初始化变量.

::: details
```c++
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```
:::

任何包含了显式初始化的声明即成定义. 我们能给由`extern`关键字标记的变量赋一个初始值, 但是这么做抵消了`extern`的作用. `extern`语句如果包含初始值就不再是声明, 而变成定义了.

::: details
```c++
extern double pi = 3.1416; // 定义
```
:::

而在函数题内部, 如果试图初始化一个由`extern`关键字标记的变量, 将引发错误.

::: tip
变量能且只能被定义一次, 但是可以被多次声明. 如果要在多个文件中使用同一个变量, 就必须将声明和定义分离. 此时, 变量的定义必须出现且只能出现在一个文件中, 而其他用到该变量的文件必须对其进行声明, 却绝不能重复定义.
:::

### 标识符

C++的标识符由字母, 数字和下划线组成, 其中, 必须以字母或者下划线开头. 标识符的长度没有限制, 但是对大小写敏感.

C++的保留字不能被用作标识符. 同时, C++也为标准库保留了一些名字, 用户自定义的标识符中不能连续出现两个下划线, 也不能以下划线紧连大写字母开头. 此外, 定义在函数体以外的标识符不能以下划线开头.

#### 变量命名规范

变量命名有很多约定俗成的规范:

- 标识符要能体现实际含义
- 变量名一般用小写字母, 如`index`, 不要用`Index`和`INDEX`
- 用户自定义的类名一般以大写字母开头, 如`Sales_item`	
- 如果标识符由多个单词组成, 则单词之间应用很明显的区分, 如`student_loan`或者`studentLoan`, 不要使用`studentloan`

C++关键字请见: https://learn.microsoft.com/zh-cn/cpp/cpp/keywords-cpp?view=msvc-170

### 名字的作用域

不论式在程序的什么位置, 使用到的每个名字都会指向一个特定的实体: 变量, 函数, 类型等. 然而, 同一个名字如果出现在程序的不同位置, 也可能指向的式不同实体.

作用域式程序的一部分, 在其中名字有其特定的含义. C++中大多数作用域都以花括号分隔. 同一个名字在不同的作用域中可能指向不同的实体. 名字的有效区域始于名字的声明语句, 以声明语句所在的作用域末端为结束.

::: details
```c++
#include <iostream>
int main() {
	int sum = 0;
	for (int val = 1; val <= 10; ++val) {
		sum += val;
	}
	std::cout << "Sum of 1 to 10 inclusive is " << sum << std::endl;
	return 0;
}
```
这段程序定义了3个名字: `main`, `sum`和`val`, 同时使用了命名空间的名字`std`, 该空间提供了2个名字`cout`和`cin`供程序使用. 

名字`main`定义于所有的花括号之外, 它和其他大多数定义在函数体外的名字一样具有全局作用域. 一旦声明后, 全局作用域内的名字在整个程序的范围内都可以使用. 名字`sum`定义于`main`函数所限定的作用域之内, 从声明`sum`开始直到`main`函数结束为止都可以访问它, 但是出了`main`函数所在的块就无法访问了, 因此说变量`sum`拥有块作用域. 名字`val`定义于`for`语句内, 在`for`语句之内可以访问`val`, 但是在`main`函数的其他部分就不能再访问它了.	
:::

::: tip
一般来说, 在对象第一次被使用的地方附近定义它式一种很好的选择, 因为这样做有助于更容易找到变量的定义. 更重要的式, 当变量的定义和它第一次被使用的地方很近的时候, 我们也会赋给它一个比较合理的初始值.
:::

#### 嵌套作用域

作用域能够彼此包含, 被包含(或者说被嵌套)的作用域被称为内层作用域, 包含着别的作用域的作用域称为外层作用域.

作用域中一旦声明了某个名字, 它所嵌套着的所有作用域中都能访问该名字. 同时, 允许在内层作用域中重新定义外城作用域的已有名字.

::: details
```c++
#include <iostream>

int reused = 42;
int main()
{
    int unique = 0;
    std::cout <<  reused << " " << unique << std::endl; // 输出42 0
    int reused = 0;
    std::cout << reused <<  " " <<  unique << std::endl; // 输出0 0
    std::cout << ::reused << " " << unique << std::endl; // 输出42 0
    return 0;
}
```
第一个输出出现在局部变量`reused`定义之前, 因此这条语句使用全局作用域中定义的名字`reused`, 输出`42 0`. 第二个输出发生在局部变量`reused`定义之后, 此时局部变量`reused`正在作用域内, 因此第二条输出语句使用的是局部变量`reused`而非全局变量, 输出`0 0`. 第三个输出使用作用域操作符来覆盖默认的作用域规则, 因为全局作用域本身没有名字, 所以当作用域操作符的左侧为空的时候, 向全局作用域发出请求获取作用域操作符右侧名字对应的变量. 结果是, 第三条输出语句使用全局变量`reused`, 输出`42 0`.
:::

## 复合类型

复合类型是指基于其他类型定义的类型. C++有几种复合类型, 本节中会将两种: 引用和指针. 

与我们已经掌握的变量声明相比, 定义复合类型的变量要复杂很多. 一条简单的声明语句由一个数据类型和一个紧随其后的变量名列表组成. 更加通用的描述是, 一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成, 每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型.

到目前为止, 我们接触的声明语句都只是基本数据类型的变量. 后面还会遇到包含复合类型的声明, 它们可以基于基本数据类型扩展出更加复杂的类型, 然后用来定义变量.

### 引用


引用为对象起了另外一个名字, 引用类型引用另外一种类型, 通过将声明
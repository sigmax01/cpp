---
title: 类型
layout: doc
navbar: true
sidebar: true
aside: true
outline: deep
lastUpdated: true
editLink: true
footer: true
---

## 基本内置类型

### 算术类型

算术类型主要分为整型和浮点型. 尺寸在不同的机器上有所差别. 下表列出了C++标准规定的尺寸的最小值, 同时允许编译器赋予这些类型更大的尺寸.

| 类型         | 含义            | 最小尺寸      |
|--------------|-----------------|---------------|
| bool         | 布尔类型        | 未定义        |
| char         | 字符            | 8 位          |
| wchar_t      | 宽字符          | 16 位         |
| char16_t     | Unicode 字符    | 16 位         |
| char32_t     | Unicode 字符    | 32 位         |
| short        | 短整型          | 16 位         |
| int          | 整型            | 16 位         |
| long         | 长整型          | 32 位         |
| long long    | 长整型          | 64 位         |
| float        | 单精度浮点数    | 6 位有效数字  |
| double       | 双精度浮点数    | 10 位有效数字 |
| long double  | 扩展精度浮点数  | 10 位有效数字 |

C++中最基本的字符类型是`char`, 它用于存储基本字符集中的任意字符的对应树脂, 也就是字符在机器字符集中的数值, 通常是一个字节的大小. 

::: tip
在C++中, 基本字符集是指一种最低限度的字符集合, 包含编程语言中必需的字符, 这些字符如字母和数字, 空格, 标点符号, 操作符, 换行符, 回车符, 制表符等等.
:::

C++还提供了多种扩展字符类型, 以支持更大范围的字符集(国际化), 这些类型包括`wchar_t`, `char16_t`和`char32_t`. `wchar_t`是C++早期设计的宽字符类型, 不针对Unicode, 用于表示大于一个字节的字符, 它的大小在不同的平台上不一致. `char16_t`和`char32_t`由C++11引入, 是专门为Unicode设计的, 大小固定, 能够确保跨平台统一, 一致.

除了字符类型外, C++中的其他整数类型可能表示不同大小的整数. 标准规定`int`至少和`short`一样大, `long`至少和`int`一样大, `long long`至少和`long`一样大.

浮点型可以表示单精度, 双精度和扩展精度值, C++标准制定了一个浮点数有效位数的最小值, 然而大多数编译器都实现了更高的精度. 通常, `float`以1个字(32bit)来表示, `double`以2个字(64bit)来表示, `long double`以3个或4个字(96或128bit)来表示. 一般来说, 类型`float`和`double`分别有7和16个有效位, 类型`long double`常被用于有特殊浮点需求的硬件, 具体实现不同, 精度也不同.

::: tip
可寻址的最小内存块称为“字节”, 存储的基本单元称为“字”, 它通常是由几个字节组成的. 大多数机器的字节由8bit构成, 字则由32或者64bit构成, 也就是4或者8字节.
:::

#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外, 其他整型可以划分为带符号的(signed)和无符号的(unsigned)两种, 带符号类型可以表示正数, 负数或0, 无符号类型则仅能表示大于等于0的值.

类型`int`, `short`, `long`和`long long`都是带符号的, 通过在这些类型前面添加`unsigned`就可以得到无符号类型, 例如`unsigned long`, 类型`unsigned int`可以缩写为`unsigned`.

与其他整型不同, 字符型被分为了三种: `char`, `signed char`和`unsigned char`. 特别需要注意的是, 类型`char`和类型`signed char`并不一样. 因为`char`在某些编译器上可以视为无符号的, 有些视为有符号的(C++没有规定`char`是否带符号), 对于`unsigned char`, 在8位的情况下, 它可以表示从0到255之间的值; 对于`signed char`, 理论上应该表示-127到127的范围, 但是在大多数计算机上通常是-128到127.

::: tip
如何选择类型?
- 当明确知道数值不可能为负的时候, 应该选用无符号类型
- 使用`int`执行整数运算, 如果数值超过了`int`的范围, 用`long long`
- 不要在算术表达式里面用`char`和`bool`, 只有在存放字符或者布尔值的时候才使用它们. 因为类型`char`在某些机器上是有符号的, 在另一些机器上是无符号的, 如果用`char`进行算术运算很容易出错, 需要制定类型为`signed char`/`unsigned char`
- 执行浮点数运算选用`double`, 这是因为`float`通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几. 对于某些机器来说, 双精度甚至比单精度快
:::

### 类型转换

对象的类型定义了对象能包含的数据和能参与的运算, 其中一种运算是被大多数类型支持的, 就是将对象从一种给定类型转换到另一种类型. 

当在程序中我们使用了一种类型而其实对象应该采取另一种类型的时候, 程序会进行自动类型转换. 如给某种类型的对象强行赋予了另一种类型的值的时候, 类型所能表示的值的范围决定了转换过程:

- 当我们将一个非布尔类型的算术赋值给布尔类型的时候, 初始值为0的结果为`false`, 否则结果为`true`
- 当我们将一个布尔值复制给非布尔类型的时候, 初始值为`false`, 初始值为`true`则结果为1
- 当我们把一个浮点数赋值给整数类型的时候, 进行了近似处理, 结果值将仅保留浮点数中小数点之前的部分
- 当我们把一个整数值赋值给浮点类型的时候, 小数部分记为0, 如果整数所占的空间超过了浮点类型的容量, 精度可能会有损失
- 当我们赋给一个无符号类型一个超过它表示范围的值时, 结果是初始值对无符号类型表示数值总数取模后的余数. 例如, 8bit大小的`unsigned char`可以表示0到255区间范围内的值, 所以如果赋了一个区间以外的值, 实际结果是该值对256取模后所得的余数, 因此, 把-1复制给8bit大小的`unsigned char`所得的结果是255
- 当我们赋给带符号类型一个超出它表示范围的值时, 结果是未定义. 此时, 程序可能继续工作, 可能奔溃, 也可能生成垃圾数据

::: warning
“无法预知”的行为源于编译器无须(有时候是不能)检测的错误, 即使代码编译通过了, 如果程序执行了一条未定义的表达式, 仍有可能产生错误. 不幸的是, 在某些情况/某些编译器下, 含有无法预知行为的程序也能正常执行, 但是我们无法确保同样一个程序在别的编译器下能够正常工作, 甚至是已经编译通过的代码再次执行也可能会出错. 此外, 也不能认为程序对一组输入有效, 对另一组输入就一定有效. 程序也应该尽量避免依赖于实现环境的行为. 如果我们把`int`的尺寸看成是一个确定不变的值, 那么这样的程序就被称为是“不可移植的”. 当程序移植到别的机器上后, 依赖于当前实现环境的程序就可能发生错误.
:::

当在程序的某处使用了算术类型而需求是另一种类型的时候, 编译器同样会自动执行上述转换. 例如, 如果我们使用了一个非布尔值作为条件, 那么它会被自动转换为布尔值. 这一做法和把非布尔值赋值给布尔变量的操作完全一样.